"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-copy";
exports.ids = ["vendor-chunks/fast-copy"];
exports.modules = {

/***/ "(ssr)/./node_modules/fast-copy/dist/cjs/index.cjs":
/*!***************************************************!*\
  !*** ./node_modules/fast-copy/dist/cjs/index.cjs ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst toStringFunction = Function.prototype.toString;\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst toStringObject = Object.prototype.toString;\n/**\n * Get an empty version of the object with the same prototype it has.\n */\nfunction getCleanClone(prototype) {\n    if (!prototype) {\n        return Object.create(null);\n    }\n    const Constructor = prototype.constructor;\n    if (Constructor === Object) {\n        return prototype === Object.prototype ? {} : Object.create(prototype);\n    }\n    if (Constructor && ~toStringFunction.call(Constructor).indexOf('[native code]')) {\n        try {\n            return new Constructor();\n        }\n        catch (_a) {\n            // Ignore\n        }\n    }\n    return Object.create(prototype);\n}\n/**\n * Get the tag of the value passed, so that the correct copier can be used.\n */\nfunction getTag(value) {\n    const stringTag = value[Symbol.toStringTag];\n    if (stringTag) {\n        return stringTag;\n    }\n    const type = toStringObject.call(value);\n    return type.substring(8, type.length - 1);\n}\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst { hasOwnProperty, propertyIsEnumerable } = Object.prototype;\nfunction copyOwnDescriptor(original, clone, property, state) {\n    const ownDescriptor = Object.getOwnPropertyDescriptor(original, property) || {\n        configurable: true,\n        enumerable: true,\n        value: original[property],\n        writable: true,\n    };\n    const descriptor = ownDescriptor.get || ownDescriptor.set\n        ? ownDescriptor\n        : {\n            configurable: ownDescriptor.configurable,\n            enumerable: ownDescriptor.enumerable,\n            value: state.copier(ownDescriptor.value, state),\n            writable: ownDescriptor.writable,\n        };\n    try {\n        Object.defineProperty(clone, property, descriptor);\n    }\n    catch (_a) {\n        // The above can fail on node in extreme edge cases, so fall back to the loose assignment.\n        clone[property] = descriptor.get ? descriptor.get() : descriptor.value;\n    }\n}\n/**\n * Striclty copy all properties contained on the object.\n */\nfunction copyOwnPropertiesStrict(value, clone, state) {\n    const names = Object.getOwnPropertyNames(value);\n    for (let index = 0; index < names.length; ++index) {\n        copyOwnDescriptor(value, clone, names[index], state);\n    }\n    const symbols = Object.getOwnPropertySymbols(value);\n    for (let index = 0; index < symbols.length; ++index) {\n        copyOwnDescriptor(value, clone, symbols[index], state);\n    }\n    return clone;\n}\n/**\n * Deeply copy the indexed values in the array.\n */\nfunction copyArrayLoose(array, state) {\n    const clone = new state.Constructor();\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(array, clone);\n    for (let index = 0; index < array.length; ++index) {\n        clone[index] = state.copier(array[index], state);\n    }\n    return clone;\n}\n/**\n * Deeply copy the indexed values in the array, as well as any custom properties.\n */\nfunction copyArrayStrict(array, state) {\n    const clone = new state.Constructor();\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(array, clone);\n    return copyOwnPropertiesStrict(array, clone, state);\n}\n/**\n * Copy the contents of the ArrayBuffer.\n */\nfunction copyArrayBuffer(arrayBuffer, _state) {\n    return arrayBuffer.slice(0);\n}\n/**\n * Create a new Blob with the contents of the original.\n */\nfunction copyBlob(blob, _state) {\n    return blob.slice(0, blob.size, blob.type);\n}\n/**\n * Create a new DataView with the contents of the original.\n */\nfunction copyDataView(dataView, state) {\n    return new state.Constructor(copyArrayBuffer(dataView.buffer));\n}\n/**\n * Create a new Date based on the time of the original.\n */\nfunction copyDate(date, state) {\n    return new state.Constructor(date.getTime());\n}\n/**\n * Deeply copy the keys and values of the original.\n */\nfunction copyMapLoose(map, state) {\n    const clone = new state.Constructor();\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(map, clone);\n    map.forEach((value, key) => {\n        clone.set(key, state.copier(value, state));\n    });\n    return clone;\n}\n/**\n * Deeply copy the keys and values of the original, as well as any custom properties.\n */\nfunction copyMapStrict(map, state) {\n    return copyOwnPropertiesStrict(map, copyMapLoose(map, state), state);\n}\n/**\n * Deeply copy the properties (keys and symbols) and values of the original.\n */\nfunction copyObjectLoose(object, state) {\n    const clone = getCleanClone(state.prototype);\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(object, clone);\n    for (const key in object) {\n        if (hasOwnProperty.call(object, key)) {\n            clone[key] = state.copier(object[key], state);\n        }\n    }\n    const symbols = Object.getOwnPropertySymbols(object);\n    for (let index = 0; index < symbols.length; ++index) {\n        const symbol = symbols[index];\n        if (propertyIsEnumerable.call(object, symbol)) {\n            clone[symbol] = state.copier(object[symbol], state);\n        }\n    }\n    return clone;\n}\n/**\n * Deeply copy the properties (keys and symbols) and values of the original, as well\n * as any hidden or non-enumerable properties.\n */\nfunction copyObjectStrict(object, state) {\n    const clone = getCleanClone(state.prototype);\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(object, clone);\n    return copyOwnPropertiesStrict(object, clone, state);\n}\n/**\n * Create a new primitive wrapper from the value of the original.\n */\nfunction copyPrimitiveWrapper(primitiveObject, state) {\n    return new state.Constructor(primitiveObject.valueOf());\n}\n/**\n * Create a new RegExp based on the value and flags of the original.\n */\nfunction copyRegExp(regExp, state) {\n    const clone = new state.Constructor(regExp.source, regExp.flags);\n    clone.lastIndex = regExp.lastIndex;\n    return clone;\n}\n/**\n * Return the original value (an identity function).\n *\n * @note\n * THis is used for objects that cannot be copied, such as WeakMap.\n */\nfunction copySelf(value, _state) {\n    return value;\n}\n/**\n * Deeply copy the values of the original.\n */\nfunction copySetLoose(set, state) {\n    const clone = new state.Constructor();\n    // set in the cache immediately to be able to reuse the object recursively\n    state.cache.set(set, clone);\n    set.forEach((value) => {\n        clone.add(state.copier(value, state));\n    });\n    return clone;\n}\n/**\n * Deeply copy the values of the original, as well as any custom properties.\n */\nfunction copySetStrict(set, state) {\n    return copyOwnPropertiesStrict(set, copySetLoose(set, state), state);\n}\n\nfunction createDefaultCache() {\n    return new WeakMap();\n}\nfunction getOptions({ createCache: createCacheOverride, methods: methodsOverride, strict, }) {\n    const defaultMethods = {\n        array: strict ? copyArrayStrict : copyArrayLoose,\n        arrayBuffer: copyArrayBuffer,\n        asyncGenerator: copySelf,\n        blob: copyBlob,\n        dataView: copyDataView,\n        date: copyDate,\n        error: copySelf,\n        generator: copySelf,\n        map: strict ? copyMapStrict : copyMapLoose,\n        object: strict ? copyObjectStrict : copyObjectLoose,\n        regExp: copyRegExp,\n        set: strict ? copySetStrict : copySetLoose,\n    };\n    const methods = methodsOverride ? Object.assign(defaultMethods, methodsOverride) : defaultMethods;\n    const copiers = getTagSpecificCopiers(methods);\n    const createCache = createCacheOverride || createDefaultCache;\n    // Extra safety check to ensure that object and array copiers are always provided,\n    // avoiding runtime errors.\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!copiers.Object || !copiers.Array) {\n        throw new Error('An object and array copier must be provided.');\n    }\n    return { createCache, copiers, methods, strict: Boolean(strict) };\n}\n/**\n * Get the copiers used for each specific object tag.\n */\nfunction getTagSpecificCopiers(methods) {\n    return {\n        Arguments: methods.object,\n        Array: methods.array,\n        ArrayBuffer: methods.arrayBuffer,\n        AsyncGenerator: methods.asyncGenerator,\n        Blob: methods.blob,\n        Boolean: copyPrimitiveWrapper,\n        DataView: methods.dataView,\n        Date: methods.date,\n        Error: methods.error,\n        Float32Array: methods.arrayBuffer,\n        Float64Array: methods.arrayBuffer,\n        Generator: methods.generator,\n        Int8Array: methods.arrayBuffer,\n        Int16Array: methods.arrayBuffer,\n        Int32Array: methods.arrayBuffer,\n        Map: methods.map,\n        Number: copyPrimitiveWrapper,\n        Object: methods.object,\n        Promise: copySelf,\n        RegExp: methods.regExp,\n        Set: methods.set,\n        String: copyPrimitiveWrapper,\n        WeakMap: copySelf,\n        WeakSet: copySelf,\n        Uint8Array: methods.arrayBuffer,\n        Uint8ClampedArray: methods.arrayBuffer,\n        Uint16Array: methods.arrayBuffer,\n        Uint32Array: methods.arrayBuffer,\n        Uint64Array: methods.arrayBuffer,\n    };\n}\n\n/**\n * Create a custom copier based on custom options for any of the following:\n *   - `createCache` method to create a cache for copied objects\n *   - custom copier `methods` for specific object types\n *   - `strict` mode to copy all properties with their descriptors\n */\nfunction createCopier(options = {}) {\n    const { createCache, copiers } = getOptions(options);\n    const { Array: copyArray, Object: copyObject } = copiers;\n    function copier(value, state) {\n        state.prototype = state.Constructor = undefined;\n        if (!value || typeof value !== 'object') {\n            return value;\n        }\n        if (state.cache.has(value)) {\n            return state.cache.get(value);\n        }\n        state.prototype = Object.getPrototypeOf(value);\n        // Using logical AND for speed, since optional chaining transforms to\n        // a local variable usage.\n        // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n        state.Constructor = state.prototype && state.prototype.constructor;\n        // plain objects\n        if (!state.Constructor || state.Constructor === Object) {\n            return copyObject(value, state);\n        }\n        // arrays\n        if (Array.isArray(value)) {\n            return copyArray(value, state);\n        }\n        const tagSpecificCopier = copiers[getTag(value)];\n        if (tagSpecificCopier) {\n            return tagSpecificCopier(value, state);\n        }\n        return typeof value.then === 'function' ? value : copyObject(value, state);\n    }\n    return function copy(value) {\n        return copier(value, {\n            Constructor: undefined,\n            cache: createCache(),\n            copier,\n            prototype: undefined,\n        });\n    };\n}\n/**\n * Copy an value deeply as much as possible, where strict recreation of object properties\n * are maintained. All properties (including non-enumerable ones) are copied with their\n * original property descriptors on both objects and arrays.\n */\nconst copyStrict = createCopier({ strict: true });\n/**\n * Copy an value deeply as much as possible.\n */\nconst copy = createCopier();\n\nexports.copy = copy;\nexports.copyStrict = copyStrict;\nexports.createCopier = createCopier;\n//# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZmFzdC1jb3B5L2Rpc3QvY2pzL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsdUNBQXVDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUVBQXFFO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLFlBQVksdUJBQXVCO0FBQ25DLFlBQVksdUNBQXVDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWixrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJlZWxhbmNlci1zbWFydC1jb250cmFjdC1kYXBwLy4vbm9kZV9tb2R1bGVzL2Zhc3QtY29weS9kaXN0L2Nqcy9pbmRleC5janM/ZjIyZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbmNvbnN0IHRvU3RyaW5nRnVuY3Rpb24gPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG5jb25zdCB0b1N0cmluZ09iamVjdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4vKipcbiAqIEdldCBhbiBlbXB0eSB2ZXJzaW9uIG9mIHRoZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSBwcm90b3R5cGUgaXQgaGFzLlxuICovXG5mdW5jdGlvbiBnZXRDbGVhbkNsb25lKHByb3RvdHlwZSkge1xuICAgIGlmICghcHJvdG90eXBlKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBjb25zdCBDb25zdHJ1Y3RvciA9IHByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoQ29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICByZXR1cm4gcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlID8ge30gOiBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSk7XG4gICAgfVxuICAgIGlmIChDb25zdHJ1Y3RvciAmJiB+dG9TdHJpbmdGdW5jdGlvbi5jYWxsKENvbnN0cnVjdG9yKS5pbmRleE9mKCdbbmF0aXZlIGNvZGVdJykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSk7XG59XG4vKipcbiAqIEdldCB0aGUgdGFnIG9mIHRoZSB2YWx1ZSBwYXNzZWQsIHNvIHRoYXQgdGhlIGNvcnJlY3QgY29waWVyIGNhbiBiZSB1c2VkLlxuICovXG5mdW5jdGlvbiBnZXRUYWcodmFsdWUpIHtcbiAgICBjb25zdCBzdHJpbmdUYWcgPSB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddO1xuICAgIGlmIChzdHJpbmdUYWcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1RhZztcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHRvU3RyaW5nT2JqZWN0LmNhbGwodmFsdWUpO1xuICAgIHJldHVybiB0eXBlLnN1YnN0cmluZyg4LCB0eXBlLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG5jb25zdCB7IGhhc093blByb3BlcnR5LCBwcm9wZXJ0eUlzRW51bWVyYWJsZSB9ID0gT2JqZWN0LnByb3RvdHlwZTtcbmZ1bmN0aW9uIGNvcHlPd25EZXNjcmlwdG9yKG9yaWdpbmFsLCBjbG9uZSwgcHJvcGVydHksIHN0YXRlKSB7XG4gICAgY29uc3Qgb3duRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3JpZ2luYWwsIHByb3BlcnR5KSB8fCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IG9yaWdpbmFsW3Byb3BlcnR5XSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgfTtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gb3duRGVzY3JpcHRvci5nZXQgfHwgb3duRGVzY3JpcHRvci5zZXRcbiAgICAgICAgPyBvd25EZXNjcmlwdG9yXG4gICAgICAgIDoge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBvd25EZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IG93bkRlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgICAgICAgIHZhbHVlOiBzdGF0ZS5jb3BpZXIob3duRGVzY3JpcHRvci52YWx1ZSwgc3RhdGUpLFxuICAgICAgICAgICAgd3JpdGFibGU6IG93bkRlc2NyaXB0b3Iud3JpdGFibGUsXG4gICAgICAgIH07XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb25lLCBwcm9wZXJ0eSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICAvLyBUaGUgYWJvdmUgY2FuIGZhaWwgb24gbm9kZSBpbiBleHRyZW1lIGVkZ2UgY2FzZXMsIHNvIGZhbGwgYmFjayB0byB0aGUgbG9vc2UgYXNzaWdubWVudC5cbiAgICAgICAgY2xvbmVbcHJvcGVydHldID0gZGVzY3JpcHRvci5nZXQgPyBkZXNjcmlwdG9yLmdldCgpIDogZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9XG59XG4vKipcbiAqIFN0cmljbHR5IGNvcHkgYWxsIHByb3BlcnRpZXMgY29udGFpbmVkIG9uIHRoZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPd25Qcm9wZXJ0aWVzU3RyaWN0KHZhbHVlLCBjbG9uZSwgc3RhdGUpIHtcbiAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbmFtZXMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIGNvcHlPd25EZXNjcmlwdG9yKHZhbHVlLCBjbG9uZSwgbmFtZXNbaW5kZXhdLCBzdGF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHZhbHVlKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgc3ltYm9scy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgY29weU93bkRlc2NyaXB0b3IodmFsdWUsIGNsb25lLCBzeW1ib2xzW2luZGV4XSwgc3RhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG59XG4vKipcbiAqIERlZXBseSBjb3B5IHRoZSBpbmRleGVkIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheUxvb3NlKGFycmF5LCBzdGF0ZSkge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IHN0YXRlLkNvbnN0cnVjdG9yKCk7XG4gICAgLy8gc2V0IGluIHRoZSBjYWNoZSBpbW1lZGlhdGVseSB0byBiZSBhYmxlIHRvIHJldXNlIHRoZSBvYmplY3QgcmVjdXJzaXZlbHlcbiAgICBzdGF0ZS5jYWNoZS5zZXQoYXJyYXksIGNsb25lKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXkubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIGNsb25lW2luZGV4XSA9IHN0YXRlLmNvcGllcihhcnJheVtpbmRleF0sIHN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lO1xufVxuLyoqXG4gKiBEZWVwbHkgY29weSB0aGUgaW5kZXhlZCB2YWx1ZXMgaW4gdGhlIGFycmF5LCBhcyB3ZWxsIGFzIGFueSBjdXN0b20gcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5U3RyaWN0KGFycmF5LCBzdGF0ZSkge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IHN0YXRlLkNvbnN0cnVjdG9yKCk7XG4gICAgLy8gc2V0IGluIHRoZSBjYWNoZSBpbW1lZGlhdGVseSB0byBiZSBhYmxlIHRvIHJldXNlIHRoZSBvYmplY3QgcmVjdXJzaXZlbHlcbiAgICBzdGF0ZS5jYWNoZS5zZXQoYXJyYXksIGNsb25lKTtcbiAgICByZXR1cm4gY29weU93blByb3BlcnRpZXNTdHJpY3QoYXJyYXksIGNsb25lLCBzdGF0ZSk7XG59XG4vKipcbiAqIENvcHkgdGhlIGNvbnRlbnRzIG9mIHRoZSBBcnJheUJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5QnVmZmVyKGFycmF5QnVmZmVyLCBfc3RhdGUpIHtcbiAgICByZXR1cm4gYXJyYXlCdWZmZXIuc2xpY2UoMCk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBCbG9iIHdpdGggdGhlIGNvbnRlbnRzIG9mIHRoZSBvcmlnaW5hbC5cbiAqL1xuZnVuY3Rpb24gY29weUJsb2IoYmxvYiwgX3N0YXRlKSB7XG4gICAgcmV0dXJuIGJsb2Iuc2xpY2UoMCwgYmxvYi5zaXplLCBibG9iLnR5cGUpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgRGF0YVZpZXcgd2l0aCB0aGUgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsLlxuICovXG5mdW5jdGlvbiBjb3B5RGF0YVZpZXcoZGF0YVZpZXcsIHN0YXRlKSB7XG4gICAgcmV0dXJuIG5ldyBzdGF0ZS5Db25zdHJ1Y3Rvcihjb3B5QXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBEYXRlIGJhc2VkIG9uIHRoZSB0aW1lIG9mIHRoZSBvcmlnaW5hbC5cbiAqL1xuZnVuY3Rpb24gY29weURhdGUoZGF0ZSwgc3RhdGUpIHtcbiAgICByZXR1cm4gbmV3IHN0YXRlLkNvbnN0cnVjdG9yKGRhdGUuZ2V0VGltZSgpKTtcbn1cbi8qKlxuICogRGVlcGx5IGNvcHkgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiB0aGUgb3JpZ2luYWwuXG4gKi9cbmZ1bmN0aW9uIGNvcHlNYXBMb29zZShtYXAsIHN0YXRlKSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgc3RhdGUuQ29uc3RydWN0b3IoKTtcbiAgICAvLyBzZXQgaW4gdGhlIGNhY2hlIGltbWVkaWF0ZWx5IHRvIGJlIGFibGUgdG8gcmV1c2UgdGhlIG9iamVjdCByZWN1cnNpdmVseVxuICAgIHN0YXRlLmNhY2hlLnNldChtYXAsIGNsb25lKTtcbiAgICBtYXAuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBjbG9uZS5zZXQoa2V5LCBzdGF0ZS5jb3BpZXIodmFsdWUsIHN0YXRlKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb25lO1xufVxuLyoqXG4gKiBEZWVwbHkgY29weSB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIHRoZSBvcmlnaW5hbCwgYXMgd2VsbCBhcyBhbnkgY3VzdG9tIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIGNvcHlNYXBTdHJpY3QobWFwLCBzdGF0ZSkge1xuICAgIHJldHVybiBjb3B5T3duUHJvcGVydGllc1N0cmljdChtYXAsIGNvcHlNYXBMb29zZShtYXAsIHN0YXRlKSwgc3RhdGUpO1xufVxuLyoqXG4gKiBEZWVwbHkgY29weSB0aGUgcHJvcGVydGllcyAoa2V5cyBhbmQgc3ltYm9scykgYW5kIHZhbHVlcyBvZiB0aGUgb3JpZ2luYWwuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3RMb29zZShvYmplY3QsIHN0YXRlKSB7XG4gICAgY29uc3QgY2xvbmUgPSBnZXRDbGVhbkNsb25lKHN0YXRlLnByb3RvdHlwZSk7XG4gICAgLy8gc2V0IGluIHRoZSBjYWNoZSBpbW1lZGlhdGVseSB0byBiZSBhYmxlIHRvIHJldXNlIHRoZSBvYmplY3QgcmVjdXJzaXZlbHlcbiAgICBzdGF0ZS5jYWNoZS5zZXQob2JqZWN0LCBjbG9uZSk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgY2xvbmVba2V5XSA9IHN0YXRlLmNvcGllcihvYmplY3Rba2V5XSwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHN5bWJvbHMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIGNvbnN0IHN5bWJvbCA9IHN5bWJvbHNbaW5kZXhdO1xuICAgICAgICBpZiAocHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCkpIHtcbiAgICAgICAgICAgIGNsb25lW3N5bWJvbF0gPSBzdGF0ZS5jb3BpZXIob2JqZWN0W3N5bWJvbF0sIHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG59XG4vKipcbiAqIERlZXBseSBjb3B5IHRoZSBwcm9wZXJ0aWVzIChrZXlzIGFuZCBzeW1ib2xzKSBhbmQgdmFsdWVzIG9mIHRoZSBvcmlnaW5hbCwgYXMgd2VsbFxuICogYXMgYW55IGhpZGRlbiBvciBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0U3RyaWN0KG9iamVjdCwgc3RhdGUpIHtcbiAgICBjb25zdCBjbG9uZSA9IGdldENsZWFuQ2xvbmUoc3RhdGUucHJvdG90eXBlKTtcbiAgICAvLyBzZXQgaW4gdGhlIGNhY2hlIGltbWVkaWF0ZWx5IHRvIGJlIGFibGUgdG8gcmV1c2UgdGhlIG9iamVjdCByZWN1cnNpdmVseVxuICAgIHN0YXRlLmNhY2hlLnNldChvYmplY3QsIGNsb25lKTtcbiAgICByZXR1cm4gY29weU93blByb3BlcnRpZXNTdHJpY3Qob2JqZWN0LCBjbG9uZSwgc3RhdGUpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgcHJpbWl0aXZlIHdyYXBwZXIgZnJvbSB0aGUgdmFsdWUgb2YgdGhlIG9yaWdpbmFsLlxuICovXG5mdW5jdGlvbiBjb3B5UHJpbWl0aXZlV3JhcHBlcihwcmltaXRpdmVPYmplY3QsIHN0YXRlKSB7XG4gICAgcmV0dXJuIG5ldyBzdGF0ZS5Db25zdHJ1Y3RvcihwcmltaXRpdmVPYmplY3QudmFsdWVPZigpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFJlZ0V4cCBiYXNlZCBvbiB0aGUgdmFsdWUgYW5kIGZsYWdzIG9mIHRoZSBvcmlnaW5hbC5cbiAqL1xuZnVuY3Rpb24gY29weVJlZ0V4cChyZWdFeHAsIHN0YXRlKSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgc3RhdGUuQ29uc3RydWN0b3IocmVnRXhwLnNvdXJjZSwgcmVnRXhwLmZsYWdzKTtcbiAgICBjbG9uZS5sYXN0SW5kZXggPSByZWdFeHAubGFzdEluZGV4O1xuICAgIHJldHVybiBjbG9uZTtcbn1cbi8qKlxuICogUmV0dXJuIHRoZSBvcmlnaW5hbCB2YWx1ZSAoYW4gaWRlbnRpdHkgZnVuY3Rpb24pLlxuICpcbiAqIEBub3RlXG4gKiBUSGlzIGlzIHVzZWQgZm9yIG9iamVjdHMgdGhhdCBjYW5ub3QgYmUgY29waWVkLCBzdWNoIGFzIFdlYWtNYXAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTZWxmKHZhbHVlLCBfc3RhdGUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIERlZXBseSBjb3B5IHRoZSB2YWx1ZXMgb2YgdGhlIG9yaWdpbmFsLlxuICovXG5mdW5jdGlvbiBjb3B5U2V0TG9vc2Uoc2V0LCBzdGF0ZSkge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IHN0YXRlLkNvbnN0cnVjdG9yKCk7XG4gICAgLy8gc2V0IGluIHRoZSBjYWNoZSBpbW1lZGlhdGVseSB0byBiZSBhYmxlIHRvIHJldXNlIHRoZSBvYmplY3QgcmVjdXJzaXZlbHlcbiAgICBzdGF0ZS5jYWNoZS5zZXQoc2V0LCBjbG9uZSk7XG4gICAgc2V0LmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgIGNsb25lLmFkZChzdGF0ZS5jb3BpZXIodmFsdWUsIHN0YXRlKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb25lO1xufVxuLyoqXG4gKiBEZWVwbHkgY29weSB0aGUgdmFsdWVzIG9mIHRoZSBvcmlnaW5hbCwgYXMgd2VsbCBhcyBhbnkgY3VzdG9tIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTZXRTdHJpY3Qoc2V0LCBzdGF0ZSkge1xuICAgIHJldHVybiBjb3B5T3duUHJvcGVydGllc1N0cmljdChzZXQsIGNvcHlTZXRMb29zZShzZXQsIHN0YXRlKSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0Q2FjaGUoKSB7XG4gICAgcmV0dXJuIG5ldyBXZWFrTWFwKCk7XG59XG5mdW5jdGlvbiBnZXRPcHRpb25zKHsgY3JlYXRlQ2FjaGU6IGNyZWF0ZUNhY2hlT3ZlcnJpZGUsIG1ldGhvZHM6IG1ldGhvZHNPdmVycmlkZSwgc3RyaWN0LCB9KSB7XG4gICAgY29uc3QgZGVmYXVsdE1ldGhvZHMgPSB7XG4gICAgICAgIGFycmF5OiBzdHJpY3QgPyBjb3B5QXJyYXlTdHJpY3QgOiBjb3B5QXJyYXlMb29zZSxcbiAgICAgICAgYXJyYXlCdWZmZXI6IGNvcHlBcnJheUJ1ZmZlcixcbiAgICAgICAgYXN5bmNHZW5lcmF0b3I6IGNvcHlTZWxmLFxuICAgICAgICBibG9iOiBjb3B5QmxvYixcbiAgICAgICAgZGF0YVZpZXc6IGNvcHlEYXRhVmlldyxcbiAgICAgICAgZGF0ZTogY29weURhdGUsXG4gICAgICAgIGVycm9yOiBjb3B5U2VsZixcbiAgICAgICAgZ2VuZXJhdG9yOiBjb3B5U2VsZixcbiAgICAgICAgbWFwOiBzdHJpY3QgPyBjb3B5TWFwU3RyaWN0IDogY29weU1hcExvb3NlLFxuICAgICAgICBvYmplY3Q6IHN0cmljdCA/IGNvcHlPYmplY3RTdHJpY3QgOiBjb3B5T2JqZWN0TG9vc2UsXG4gICAgICAgIHJlZ0V4cDogY29weVJlZ0V4cCxcbiAgICAgICAgc2V0OiBzdHJpY3QgPyBjb3B5U2V0U3RyaWN0IDogY29weVNldExvb3NlLFxuICAgIH07XG4gICAgY29uc3QgbWV0aG9kcyA9IG1ldGhvZHNPdmVycmlkZSA/IE9iamVjdC5hc3NpZ24oZGVmYXVsdE1ldGhvZHMsIG1ldGhvZHNPdmVycmlkZSkgOiBkZWZhdWx0TWV0aG9kcztcbiAgICBjb25zdCBjb3BpZXJzID0gZ2V0VGFnU3BlY2lmaWNDb3BpZXJzKG1ldGhvZHMpO1xuICAgIGNvbnN0IGNyZWF0ZUNhY2hlID0gY3JlYXRlQ2FjaGVPdmVycmlkZSB8fCBjcmVhdGVEZWZhdWx0Q2FjaGU7XG4gICAgLy8gRXh0cmEgc2FmZXR5IGNoZWNrIHRvIGVuc3VyZSB0aGF0IG9iamVjdCBhbmQgYXJyYXkgY29waWVycyBhcmUgYWx3YXlzIHByb3ZpZGVkLFxuICAgIC8vIGF2b2lkaW5nIHJ1bnRpbWUgZXJyb3JzLlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgaWYgKCFjb3BpZXJzLk9iamVjdCB8fCAhY29waWVycy5BcnJheSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIG9iamVjdCBhbmQgYXJyYXkgY29waWVyIG11c3QgYmUgcHJvdmlkZWQuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IGNyZWF0ZUNhY2hlLCBjb3BpZXJzLCBtZXRob2RzLCBzdHJpY3Q6IEJvb2xlYW4oc3RyaWN0KSB9O1xufVxuLyoqXG4gKiBHZXQgdGhlIGNvcGllcnMgdXNlZCBmb3IgZWFjaCBzcGVjaWZpYyBvYmplY3QgdGFnLlxuICovXG5mdW5jdGlvbiBnZXRUYWdTcGVjaWZpY0NvcGllcnMobWV0aG9kcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIEFyZ3VtZW50czogbWV0aG9kcy5vYmplY3QsXG4gICAgICAgIEFycmF5OiBtZXRob2RzLmFycmF5LFxuICAgICAgICBBcnJheUJ1ZmZlcjogbWV0aG9kcy5hcnJheUJ1ZmZlcixcbiAgICAgICAgQXN5bmNHZW5lcmF0b3I6IG1ldGhvZHMuYXN5bmNHZW5lcmF0b3IsXG4gICAgICAgIEJsb2I6IG1ldGhvZHMuYmxvYixcbiAgICAgICAgQm9vbGVhbjogY29weVByaW1pdGl2ZVdyYXBwZXIsXG4gICAgICAgIERhdGFWaWV3OiBtZXRob2RzLmRhdGFWaWV3LFxuICAgICAgICBEYXRlOiBtZXRob2RzLmRhdGUsXG4gICAgICAgIEVycm9yOiBtZXRob2RzLmVycm9yLFxuICAgICAgICBGbG9hdDMyQXJyYXk6IG1ldGhvZHMuYXJyYXlCdWZmZXIsXG4gICAgICAgIEZsb2F0NjRBcnJheTogbWV0aG9kcy5hcnJheUJ1ZmZlcixcbiAgICAgICAgR2VuZXJhdG9yOiBtZXRob2RzLmdlbmVyYXRvcixcbiAgICAgICAgSW50OEFycmF5OiBtZXRob2RzLmFycmF5QnVmZmVyLFxuICAgICAgICBJbnQxNkFycmF5OiBtZXRob2RzLmFycmF5QnVmZmVyLFxuICAgICAgICBJbnQzMkFycmF5OiBtZXRob2RzLmFycmF5QnVmZmVyLFxuICAgICAgICBNYXA6IG1ldGhvZHMubWFwLFxuICAgICAgICBOdW1iZXI6IGNvcHlQcmltaXRpdmVXcmFwcGVyLFxuICAgICAgICBPYmplY3Q6IG1ldGhvZHMub2JqZWN0LFxuICAgICAgICBQcm9taXNlOiBjb3B5U2VsZixcbiAgICAgICAgUmVnRXhwOiBtZXRob2RzLnJlZ0V4cCxcbiAgICAgICAgU2V0OiBtZXRob2RzLnNldCxcbiAgICAgICAgU3RyaW5nOiBjb3B5UHJpbWl0aXZlV3JhcHBlcixcbiAgICAgICAgV2Vha01hcDogY29weVNlbGYsXG4gICAgICAgIFdlYWtTZXQ6IGNvcHlTZWxmLFxuICAgICAgICBVaW50OEFycmF5OiBtZXRob2RzLmFycmF5QnVmZmVyLFxuICAgICAgICBVaW50OENsYW1wZWRBcnJheTogbWV0aG9kcy5hcnJheUJ1ZmZlcixcbiAgICAgICAgVWludDE2QXJyYXk6IG1ldGhvZHMuYXJyYXlCdWZmZXIsXG4gICAgICAgIFVpbnQzMkFycmF5OiBtZXRob2RzLmFycmF5QnVmZmVyLFxuICAgICAgICBVaW50NjRBcnJheTogbWV0aG9kcy5hcnJheUJ1ZmZlcixcbiAgICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGN1c3RvbSBjb3BpZXIgYmFzZWQgb24gY3VzdG9tIG9wdGlvbnMgZm9yIGFueSBvZiB0aGUgZm9sbG93aW5nOlxuICogICAtIGBjcmVhdGVDYWNoZWAgbWV0aG9kIHRvIGNyZWF0ZSBhIGNhY2hlIGZvciBjb3BpZWQgb2JqZWN0c1xuICogICAtIGN1c3RvbSBjb3BpZXIgYG1ldGhvZHNgIGZvciBzcGVjaWZpYyBvYmplY3QgdHlwZXNcbiAqICAgLSBgc3RyaWN0YCBtb2RlIHRvIGNvcHkgYWxsIHByb3BlcnRpZXMgd2l0aCB0aGVpciBkZXNjcmlwdG9yc1xuICovXG5mdW5jdGlvbiBjcmVhdGVDb3BpZXIob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjcmVhdGVDYWNoZSwgY29waWVycyB9ID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCB7IEFycmF5OiBjb3B5QXJyYXksIE9iamVjdDogY29weU9iamVjdCB9ID0gY29waWVycztcbiAgICBmdW5jdGlvbiBjb3BpZXIodmFsdWUsIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLnByb3RvdHlwZSA9IHN0YXRlLkNvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuY2FjaGUuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmNhY2hlLmdldCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICAgICAgLy8gVXNpbmcgbG9naWNhbCBBTkQgZm9yIHNwZWVkLCBzaW5jZSBvcHRpb25hbCBjaGFpbmluZyB0cmFuc2Zvcm1zIHRvXG4gICAgICAgIC8vIGEgbG9jYWwgdmFyaWFibGUgdXNhZ2UuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLW9wdGlvbmFsLWNoYWluXG4gICAgICAgIHN0YXRlLkNvbnN0cnVjdG9yID0gc3RhdGUucHJvdG90eXBlICYmIHN0YXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcbiAgICAgICAgLy8gcGxhaW4gb2JqZWN0c1xuICAgICAgICBpZiAoIXN0YXRlLkNvbnN0cnVjdG9yIHx8IHN0YXRlLkNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXJyYXlzXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhZ1NwZWNpZmljQ29waWVyID0gY29waWVyc1tnZXRUYWcodmFsdWUpXTtcbiAgICAgICAgaWYgKHRhZ1NwZWNpZmljQ29waWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFnU3BlY2lmaWNDb3BpZXIodmFsdWUsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IGNvcHlPYmplY3QodmFsdWUsIHN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNvcHkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNvcGllcih2YWx1ZSwge1xuICAgICAgICAgICAgQ29uc3RydWN0b3I6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNhY2hlOiBjcmVhdGVDYWNoZSgpLFxuICAgICAgICAgICAgY29waWVyLFxuICAgICAgICAgICAgcHJvdG90eXBlOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgIH07XG59XG4vKipcbiAqIENvcHkgYW4gdmFsdWUgZGVlcGx5IGFzIG11Y2ggYXMgcG9zc2libGUsIHdoZXJlIHN0cmljdCByZWNyZWF0aW9uIG9mIG9iamVjdCBwcm9wZXJ0aWVzXG4gKiBhcmUgbWFpbnRhaW5lZC4gQWxsIHByb3BlcnRpZXMgKGluY2x1ZGluZyBub24tZW51bWVyYWJsZSBvbmVzKSBhcmUgY29waWVkIHdpdGggdGhlaXJcbiAqIG9yaWdpbmFsIHByb3BlcnR5IGRlc2NyaXB0b3JzIG9uIGJvdGggb2JqZWN0cyBhbmQgYXJyYXlzLlxuICovXG5jb25zdCBjb3B5U3RyaWN0ID0gY3JlYXRlQ29waWVyKHsgc3RyaWN0OiB0cnVlIH0pO1xuLyoqXG4gKiBDb3B5IGFuIHZhbHVlIGRlZXBseSBhcyBtdWNoIGFzIHBvc3NpYmxlLlxuICovXG5jb25zdCBjb3B5ID0gY3JlYXRlQ29waWVyKCk7XG5cbmV4cG9ydHMuY29weSA9IGNvcHk7XG5leHBvcnRzLmNvcHlTdHJpY3QgPSBjb3B5U3RyaWN0O1xuZXhwb3J0cy5jcmVhdGVDb3BpZXIgPSBjcmVhdGVDb3BpZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fast-copy/dist/cjs/index.cjs\n");

/***/ })

};
;